{
  "comments": [
    {
      "key": {
        "uuid": "AAAA+3//7ds\u003d",
        "filename": "arch/arm/mach-msm/clock-pcom.c",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 1000413
      },
      "writtenOn": "2011-01-26T23:50:05Z",
      "side": 1,
      "message": "i don\u0027t like this. Clock ref counting belongs in the clock code and not in the specific implementation of the on/off functions.",
      "revId": "7d5b79b1f7f9367510e225e83d9e771066c0b755",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA+3//7cM\u003d",
        "filename": "arch/arm/mach-msm/clock-pcom.c",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 1003665
      },
      "writtenOn": "2011-01-27T04:19:51Z",
      "side": 1,
      "message": "The voter clocks which need to call enable/disable on the parent clocks inside their enable/disable. If we have the refcount at the top level, we have locking issues (grabbing a lock that\u0027s already held).\n\nWe have to move the refcounting into the individual sub clock drivers so that we don\u0027t have locking issues. Not that it makes it right/wrong, but the tegra code has refcounting at two levels -- both top and inside the \"subdriver\".\n\nAlso, your voter clocks don\u0027t allow the user to do multiple enables/disables on the same clock. This would force each individual driver to refcounting in their code instead of just having matching enable/disables and not having to worry about it.\n\nSo, can we please have the ref counts pushed in?",
      "parentUuid": "AAAA+3//7ds\u003d",
      "revId": "7d5b79b1f7f9367510e225e83d9e771066c0b755",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA+3//7bs\u003d",
        "filename": "arch/arm/mach-msm/clock-pcom.c",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 1000413
      },
      "writtenOn": "2011-01-27T05:59:52Z",
      "side": 1,
      "message": "It depends on how you setup your locking. Having a single global lock can introduce locking issues if you have clock dependencies. This can be mitigated by having an individual lock per clock at the top level, which is what tegra does if you look at it more closely. \n\nI do not like pushing ref-counting down to each level because you have to replicate this code for all the soc\u0027s. It\u0027s error prone and there\u0027s just no need for it. At the clk_api level we should have a ref count that will worry about each individual clock enable/disable. We can write that code once and prove it correct.\n\nWhich voter code does not allow multiple enable/disables? Though each handle did not have an individual refcnt, it relied on the main clock\u0027s refcnt which works just fine in the current system. The drivers already have to refcount clocks technically, since they have to balance the calls to clk_enable/clk_disable. I\u0027m really not sure what point you are trying to make.\n\nNote that I\u0027m not advocating for keeping clock handles, I think your goal of moving to clkdev is definitely something I agree with. I just don\u0027t like the voter mechanism you put in place and I don\u0027t like the refcount and locking being down here at the lowest level several times over. Let\u0027s fix it.",
      "parentUuid": "AAAA+3//7cM\u003d",
      "revId": "7d5b79b1f7f9367510e225e83d9e771066c0b755",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA+3//7Xc\u003d",
        "filename": "arch/arm/mach-msm/clock-pcom.c",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 1003665
      },
      "writtenOn": "2011-01-27T20:52:56Z",
      "side": 1,
      "message": "Yes, single global lock has locking dependency issue. So, we make it one lock per clock \"subdriver\" -- Eg: clock-pcom, clock-local, clock-rpm, etc.\n\nTo me having one lock per clock seemed like an overkill on the number of locks. It also increases the no. of locks to mentally keep track of to avoid locking issues. Yes, neither of these are insurmountable, but these were what affected our decision.\n\nBut I do see your point about not having to implement refcount several times and make sure it\u0027s correct. If you look at our tree, local clock control code is a library that\u0027s used by various soc\u0027s that have local clock control - 7x30, 8660, etc. So, right now we have 3 refcounting code - pcom, rpm and local. Since local clock control code is shared, hopefully we won\u0027t have as much repetition of refcounting code.\n\nLong story short, both of us have some concerns that need to be addressed in code. I think this patch set is not perfect, but still a move in the right direction. Can we get this in and work on the refcounting clean up later?\n\nGoing to my comment on you tegra code:\n* Pick a shared clock (not the parent, but the votee handle).\n* set rate on it.\n* Enable\n* Enable\n* Disable\n* Yes, parent clock is still on, but your vote is no longer counted.\n\nThis is not how clk APIs are expected to work. The disable\u0027s shouldn\u0027t have an impact till you call the last matching one.",
      "parentUuid": "AAAA+3//7bs\u003d",
      "revId": "7d5b79b1f7f9367510e225e83d9e771066c0b755",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA+3//7XI\u003d",
        "filename": "arch/arm/mach-msm/clock-pcom.c",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 1000413
      },
      "writtenOn": "2011-01-27T21:25:21Z",
      "side": 1,
      "message": "You don\u0027t have to mentally keep track of anything. If you use the APIs, the locking is done correctly for you. You just need to make sure that you only ever traverse the tree in one direction.\n\nIf you want to use a single lock, then it is still possible very easily by adding internal clk_enable_locked() etc functions and call those from all the places. Only the clk api entry points would ever take the locks. This is doable, but I think with the number of clocks and potential re-parenting etc, doing it on a per-clock comes out to be easier to reason about.\n\nYour point of having *only* 3 implementations is itself problematic. Why do you want to take the raciest, most dangerous code out of one place and put it into 3. I still disagree with this.\n\nI honestly don\u0027t see how this patch is a move in the right direction. It doesn\u0027t buy us anything by itself. Yes we need to move to clkdev, but let\u0027s do it the right way so we don\u0027t have to rewrite this code 100 times later.\n\nregarding your tegra concert, you are making the mistake of looking at the clock ops which is where you are suggesting to put the refcounting and the locking. However when you look at clock.c, you will notice that ALL the refcounting is done at that level and then the actual management of the clock info is done at the lower levels (setting bits in registers, aggregating votes, etc.). This is what I want to see in your implementation. If you are not willing to do that, then I will have to do it myself. I believe architecturally it is the right thing to do.",
      "parentUuid": "AAAA+3//7Xc\u003d",
      "revId": "7d5b79b1f7f9367510e225e83d9e771066c0b755",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}